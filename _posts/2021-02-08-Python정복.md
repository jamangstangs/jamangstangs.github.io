---
title: Python 완전정복 1

toc: true

use_math: true

categories:

 - Python

---

## 파이썬 시작하기 전

Identifier : 프로그래밍 언어에서 이름을 붙일 때 사용하는 단어이며, 변수나 함수 이름 등으로 사용이 된다. 종류로는 snake_case와 같이 사용하는 **스네이크 케이스**와 CamelCase와 같은 **캐멀 케이스**가 있다. 

- 식별자 구분하기
  - 대문자로 시작하는 캐멀케이스 : 클래스	(소문자로 시작하는 캐멀케이스는 사용 x)
  - 스네이크 케이스
    - 괄호가 있다 -> 함수
    - 괄호가 없다 -> 변수



## 자료형

프로그래밍에서 프로그램이 처리할 수 있는 것을 **자료**라고 하며 프로그램은 이러한 자료들을 **처리**한다.

### 자료형

파이썬에서는 수많은 자료를 다룰 수 있다. 하지만 C언어와 달리 자료를 선언할 때 명시적으로 자료형을 나타내지는 않는다. 

- string : "안녕하세요~"
- bool : True, False
- number : 123, 40320.123, 222, 222

#### 자료형을 확인하는 방법

type() : 이 함수 내부에 **자료**를 넣으면 그 자료의 자료형이 무엇인지 알려준다. 

```python
>>> print(type("Hello World!"))
<class 'str'>
```

#### 문자열

- "큰 따옴표로 문자열 만들기"
- '작은 따옴표로 문자열 만들기'

위와 같은 두 가지 방식을 지원하는 이유 : (옆 동네 철수가 "파이썬은 잼이있어"라고 말했어) 괄호 안의 문장을 출력하고 싶은데 어떻게 할까?

```python
>>> print('옆 동네 철수가 "파이썬은 잼이있어"라고 말했어')
옆 동네 철수가 "파이썬은 잼이있어"라고 말했어
```

위와같이 출력이 된다. 만약 ''가 ""로 변경되었다고 생각하자. 파이썬 컴파일러 입장에서는 **"옆 동네 철수가"** 파이썬은 잼이있어 **"라고 말했어"** 이와 같이 진한 부분을 문자열로 인식한다면 그 중앙의 파트는 파이썬 입장에서는 해석할 수 없는 자료를 받은 것이다. 사용법을 익히도록.

#### 이스케이프 문자

- \\\" : 큰 따옴표
- \\' : 작은 따옴표
- \n : 줄 바꿈
- \t : 탭
- \\\\ : 역슬래시

#### 문자열 연산자

- +연산자 : "문자열" + "문자열" -> 두 문자열을 연결하는 연산자이다. 콤마(,)로 연결한 문자열과는 달리 공백이 없음을 알아두자.
- *연산자 : "문자열" * 3 -> 문자열을 반복적으로 출력이 가능하다. 
- **인덱싱** : "문자열"[index] -> 문자열에서 index번째 문자 하나를 선택할 수 있다. 물론 슬라이싱도 가능하므로 나중에 알아보도록. 그리고 파이썬은 **제로인덱스** 유형을 사용하는 언어이므로 첫번째는 인덱스 값이 0이다.
  - [-1] : 뒤의 첫 번째 문자를 나타낸다.
- **인덱스 슬라이싱** : 가장 자주 쓰이는 연산자며, 문자열의 범위를 선택하여 출력이 가능하다. 파이썬은 대표적으로 범위 지정시 **마지막 문자를 포함하지 않는 ** 언어이다. 아래의 예시로 슬라이싱을 알아보자.
  - "안녕하세요"[0:2]	-> 안녕
  - "안녕하세요"[1:3]    -> 녕하
  - "안녕하세요"[1:]      -> 녕하세요 (뒤의 공백은 자동으로 **최대위치**까지 연산이 된다.)
  - "안녕하세요"[:3]      -> 안녕하

#### 문자열의 길이 구하기

- len() : 내부에 문자열을 넣으면 문자열의 개수를 세어주는 함수이다.

### 숫자

Integer : 정수형이라고 하며 소수점이 없는 숫자를 의미한다.

Floating Point : 실수형이라고 하며 소수점이 있는 숫자를 의미한다. 

- 0과 0.0은 자료형이 다른 숫자임을 주의하자.

#### 숫자 연산자

- 사칙 연산자 : + - * /
- 정수 나누기 연산자 : // 이며, / 연산자와는 다르게 소수점 이하의 자릿수를 떼어버린 후, 정수 부분만 남기는 연산자이다.
- 나머지 연산자 : %
- 제곱 연산자 : **

### 변수와 입력

변수 : 값을 저장할 때 사용하는 **식별자**, 특히 파이썬은  C언어와는 다르게 **모든 자료형을 변수에 저장할 수 있다.** 아래의 예제로 변수를 사용하는 과정을 보여주겠다.

```python
# 변수를 선언하기
>>> money = 1000
>>> money
1000

# 변수를 참조 (변수 안에 있는 값을 사용하는 것) 참조하고 싶으면 참조할 위치에 변수명을 적어주자.
>>> money*1000
>>> 1000000
```

#### 복합 대입 연산자

기존 변수에 연산할 숫자를 단순히 연산해주는 것만으로도 **연산과 동시에 대입**을 할 수 있다.

- +=, -=, *=, /=, %=, **= 와 같은 복합대입 연산자가 있으며, 문자열에는 += 혹은 *=만 사용이 가능하다.

#### 사용자 입력

프로그램을 만들때, 프로그램 내에서 선언하는 것이 아닌, 실행시킬때 사용자로부터 받아와야 하는 값이 생길 수 있다. 이때 우리는 **input( )** 함수를 사용한다. 

```python
>>> x = input("안녕하신가. 아무 숫자나 입력해봐라>")
안녕하신가. 아무 숫자나 입력해봐라> 1
>>> print(type(x))
<class 'str'>
# 왜 숫자를 입력했는데 문자열로 뜨지? -> input 함수는 항상 문자열을 반환한다.
```

input()은 **리턴값이 문자열**이다. 따라서 입력받은 값을 숫자로 변환해야한다. 이를 하는 방법은 다음 섹션에서 설명하지.

#### 문자열 -> 숫자

자료형의 변환은 **타입 캐스팅** 이며, 변환하는 방식은 다음과 같다.

- int() : 문자열을 int 자료형으로 변환한다.
- float() : 문자열을 float 자료형으로 변환한다.

그렇다면, float형을 int로 바꾸기 완전 가능한거 아닌가요? -> 어림없는 소리이다. 부동 소수점는 정수로 변환할 수 없다.

#### 숫자 -> 문자열

반대로 숫자에서 문자열로의 변환은 다음과 같다.

- str() : 함수 안에 다른 자료형을 넣으면 문자열로 반환한다. True, False와 같이 bool형 자료도 문자열로 변환이 가능하다.

### 숫자와 문자열의 다양한 기능

#### format()

```python
"{} {} {}".format(1,2,3)
# {} 기호가 format함수 안에 있는 매개변수들과 차례대로 대치가 된다. 여기서 {}가 format()의 매개변수의 개수보다 크면 IndexError가 발생한다. 
```

기본적인 형태는 위에서 알아보았고, 아래에서 몇 가지 기능을 더 알아볼 것이다.

- 정수 출력의 다양한 형태

```python
output = "{:d}".format(12)
# {:d} 는 int 형의 자료형만 받겠다고 지정하는 의미이다.
print(output)
   12
# 5칸을 할당하고 뒤에서부터 12를 채운다. 만약 format안의 자료형을 문자열로 변환했을 때 크기가 {:n}의 n보다 크면 그냥 추력한다.

print("{:05}".format(12))
00012
# 5칸이 할당되었을 때, 채워지지 않은 부분을 0으로 채운다.
```

{:+5d} : +는 부호를 붙인다는 의미

{: 5d} : 양수의 경우 기호부분에 공백으로 배워준다.

{:+=5d} : =는 기호를 앞으로 밀어준다는 의미이다.

- 부동 소수점 출력의 다양한 형태

```python
output = "{:f}".format(12.1212)
# {:f} 는 float 형의 자료형만 받겠다고 지정하는 의미이다. 
# 0, +, 15f 등의 형태는 정수형과 같으므로 생략.

output = "{:15.3f}".format(12.1211212)
print(output)
          12.121
# 15칸을 잡고 소수점을 3자리로 출력한다.

output = "{:.3f}".format(12.12121)
print(output)
12.121
# 소수점 3자리까지 출력한다.
```

- 의미 없는 소수점 제거하기

"{:g}"의 형태는 소수점을 제거한다.

#### 대소문자 바꾸기 : upper(), lower()

원본을 변화시키는 함수는 아니며, 사용법은 아래와 같다.

```python
output = "jnrjkjrkjsnjASDFASFASDFDs"

print(output.upper())
# output = output.upper() 를 추가하면 원본을 변경시킬 수 있다. 
print(output)

# lower()을 알잘딱깔센 쓰자
```

#### 양옆 공백 제거하기 : strip()

strip() : 문자열 양 옆의공백을 제거한다.

lstrip() : 문자열 왼쪽의 공백을 제거한다.

rstrip() : 문자열 오른쪽의 공백을 제거한다.

이때 **공백**은 **띄어쓰기, 탭, 줄바꿈**을 의미한다. 따라서 아래와 같이 공백과 줄바꿈이 들어간 예시를 보여주겠다.

```python
>>> a = """
		  어이
		  파이썬 즐기고
		있냐고
		
이친구     야
"""
>>> print(a)
어이
파이썬 즐기고
있냐고
이친구     야
# 양 옆의 공백과 줄바꿈이 제거된 것을 알 수 있다.
```

#### 문자열 찾기 : find()와 rfind()

- find() : 문자열의 왼쪽부터 찾아 처음 등장하는 위치를 찾는다.
- rfind() : 문자열의 오른쪽부터 찾아 처음 등장하는 위치를 찾는다.

#### 문자열과 in 연산자

매우 중요하며, 나중에 중요한 이유는 반복문에서 알게될 것이다.

- 문자열 내부에 어떤 문자열이 있는지 in 연산자로 확인이 가능하다. 확인 방법은 아래와 같다.

```python
>>> print("안녕" in "안녕안녕방가안녕")
True
# 반환형은 bool형이며 없으면 False를 반환한다.
```

리스트와 문자열과 관계가 있지만, 곧 나올 리스트를 배울때 한번에 정리하기 위해 남겨둔다.

#### 문자열 자르기 : split()

특정 문자열을 자를 수 있으며, 반환값을 **리스트** 로 나온다. 예시를 여러개 들어보겠다. 매우 유용할거같다.

````python
output = "1 2 2 3 4 55"
output = output.split(" ")

print(output)
['1', '2', '2', '3', '4', '55'] 
````

## 조건문

### bool 자료형과 if 조건문

Boolean이라고 불리는 자료형은 문자열, 숫자와는 다르게 오직 **True나 False** 의 값만을 가질 수 있다. 이러한 자료형으로 할 수 있는 연산은 아래와 같다.

#### bool 비교 연산자

- == , != : 문자열이 같은지 다른지 비교할 수 있다.
- <, > : 문자열을 사전 순으로 비교할 수 있다.
- <=, >= 

기본적으로 숫자의 연산에 관한 결과값은 알고 있으므로 설명은 생략.

#### 논리 연산자

- not : bool을 반대로 전환
- and : 두 개의 bool이 모두 참일때 True, 그 외는 모두 False
- or : 두개 중 하나라도 참이면 True, 모두 거짓이면 False

### if 조건문 

if의 조건문에 따라 실행시키고 싶은 코드와 실행시키고 싶지 않은 코드가 있을 수 있다. 이때 if 조건문을 사용해 코드의 실행흐름을 조절할 수 있다. 기본적인 구조는 아래와 같다.

```python
if boolean expression:
    boolean expression이 참일때 실행할 문장
    boolean expression이 참일때 실행할 문장
    # 들여쓰기는 4칸 하도록
```

#### 조건문을 사용하여 날짜/시간 활용하기

````python
import datetime
# 날짜와 시간 관련 모듈을 가져온다.
now = datetime.datetime.now()
# 현재 데이트와 타임을 datetime.datetime의 자료형으로 가져온다.

print("{}년 {}월 {}일 {}시 {}분 {}초".formate(now.year, now.month, now.day, now.hour, now.minute, now.second))
# 2021년2월9일15시48분15초 와 같이 출력이 된다. 
````

위에서 기본적인 날짜/시간 출력 방법은 알아냈다. 이제 오전 오후를 나누는 프로그램을 짜보자. 조건문을 사용해서

````python
import datetime
now = datetime.datetime.now()

if now.hour<12:
    print("오전")
else:
    print("오후")
````

#### 꿀팁

파이썬 코딩할때 너무 길어지면 코드에 \기호를 입력하고 줄바꿈해서 코드를 입력하자.

```python
import datetime
now = datetime.datetime.now()

# 홀수월인지 짝수월인지 구별하는 프로그램
if now.month == 1\
		or now.month == 3\
		or now.month == 5\
		or now.month == 7\
		or now.month == 9\
		or now.month == 11:
    print("홀수네")
```

### if~else 그리고 elif 구문 

위의 예시와 같이 단순히 오전 오후로 구분이 되면 if else 구문으로 두 가지를 나누면 된다. 하지만 실생활의 문제는 더 많은 상황을 나눠서 구분해야할 수 있다. 따라서 일반적인 if ~else 구문에 **elif** 라는 구문이 추가 되어서 최종적인 문법은 아래와 같다.

```python
if 조건A:
  	A가 참일때 실행
elif 조건B:
  	B가 참일때 실행
elif 조건C:  
    C가 참일때 실행
elif 조건D:  
    D가 참일때 실행
else:
    모든 조건이 거짓일때 실행
```

쉬우니까 알잘딱깔센 해서 예시 한번만 내 컴퓨터에서 하고 넘어가겠다.

#### False로 변환되는 값

if와 같은 조건문에 다른 값이 올때는 자동으로 불로 변환한다. 기본적으로 알고 있어야 할 변환을 아래에서 설명하겠다.

- None 
- 0, 0.0 
- 빈 컨테이너

뭔가 없는거 같으면 알아서 False로 처리하자. 반대로 **무슨 값이 있으면 True**를 반환하는 것을 알고 있자.

#### pass 키워드

전체 골격을 잡아두고 내부는 아직 구현을 하지 않았을 때 사용하는 키워드로 사용법은 아래와 같고 앞으로 발견하면 아직 개발자가 개발을 안했구나 하면서 넘어가자

```python
if true:
    # 참일때 미구현 상태
    pass
else:
    # 거짓일 때 미구현 상태
    pass
```

#### pass 키워드보다 더 유용하게 사용하자! NotImplementError

pass는 파이썬을 실핼시킬때 구현을 하지 않은 부분이 있어도 원활하게 돌아가도록 해준다. 하지만 시간이 지나면 까먹을 수 있으므로 나중에 그거도 모르고 실행시킬 수 있으므로 아래와 같이 **에러를 띄워준다.** raise구문 정도는 알고 포스팅을 작성하므로 한 번 유용하게 써보러 갈까?

```python
n = int(input("정수를 입력해라"))

if n > 0:
  # 양수일 때 미구현 상태를 개발자에게 알려주고 싶다.
	raise NotImplementError
else:
  print("음수는 구현했지롱")
```

## 반복문

### 리스트와 반복문

리스트 : 숫자, 문자와 같은 자료들이 독립적이라면, 독립적인 것들을 모아 하나도 모아서 사용할 수 있게 해주는 특별한 형태의 **자료형**이다. 리스트는 [대괄호] 내부에 여러 종류의 자료를 넣어서 선언한다. 한번 아래의 예시에서 구현해보자.

```python
array = [1,2,3,True, False, "안녕"]
print(array)
```

#### 리스트 선언하고 요소에 접근하기

위의 방식과 같이 선언하며, **리스트의 기본구조는 아래와 같다.**

- [element, element, element, element,...] 
- 리스트는 한 가지의 자료형만으로도 구성할 수 있고 **여러가지 자료형**으로도 구성이 가능하다.

아래에서 리스트의 선언과 접근을 알아보겠다.

```python
arrayint = [1,2,3,4,5]
arraystring = ["하","이","ㅋ"]
# 리스트 선언은 위와 같이한다.

print(arrayint[0])
print(arraystring[0])
# 리스트 element의 접근은 list[index]의 형식으로 한다.
```

index : 리스트의 요소를 접근하는데 필요한 정수의 숫자 아래에서 다양한 리스트 접근 방식을 알아보겠다.

```python
# 1. index에 음수를 넣어서 뒤에서 element에 접근하기
lista = [1,2,3,4,5]
print(lista[-1]) # 5

# 2. 리스트에서 문자열 안의 원소를 지정하기
listb = [1,2,3,"뭐냐ㅋ",5,6]
print(listb[-3][0]) # 뭐

# 3. 리스트 안에 리스트 (리스트는 자료형을 모아서 만들었으므로 자기 자신을 또 리스트로 만들기 가능이다)
listc = [[1,2,3],[4,5,6],[7,8,9]]
print(listc[0][0]) # 0
print(listc[0]) # [1,2,3]
```

#### IndexError 예외

만약, 리스트의 크기에서 벗어난 index를 입력하여 리스트의 요소에 접근하여고 하면 컴파일러가 **IndexError** 를 띄우게된다.

#### 리스트 연산자

문자열에서 사용하는 연산자 ( * , + )는 **리스트에서도 사용이 가능하다.** 그렇다면 문자열과 리스트의 차이는 무엇일까?

- List : 인덱스를 이용해 요소에 접근해 **요소의 값을 변경이 가능하다.** **Mutable**
- 문자열 : 인덱스를 이용해 요소에 접근해 요소의 값을 변경이 불가능하다. **Immutable**

#### 리스트와 관련된 함수

**리스트에 하나의 원소만 추가하는 방법**

- append(자료) : 리스트 뒤에 요소를 추가한다.
- insert(index, 자료) : 리스트 중간에 요소를 추가한다. 여기서 insert할때는 index위치에 자료를 넣고, 겹친 자리로부터 마지막 인덱스까지의 원소들을 하나씩 미룬다.

위의 두 가지 함수의 사용 예시는 아래와 같다.

```python
lista = [1,2,3]

lista.append(1)
print(lista) # [1,2,3,4]

listb = [1,2,3,4,5]
listb.insert(3,10)
print(listb) #[1,2,3,10,4,5]

```

**리스트에 여러개의 원소를 추가하는 방법**

- extend(리스트) : append와 달리 매개변수로 리스트가 들어가며 원래 리스트 뒤에 매개변수로 입력된 리스트를 추가한다.

```python
lista = [1,2,3]
lista.extend([4,5,6])
print(lista) # [1,2,3,4,5,6]
```

하지만, + 연산자를 쓰면 가능하지 않나?

- 파괴적 함수 : extend(), append(), insert() 의 함수는 원본에 영향을 주는 함수이다.
- 비파괴적 -> + 연산자는 결과값을 이어붙인 리스트의 형태로 반환하지 원본 자체에는 변화를 주지 않는다. 하지만 문자열도 +=를 쓰면 원본을 변경할 수 있다.

**리스트에 요소 제거하기**

- del 리스트명[인덱스] :  인덱스 위치에 있는 원소를 제거한다.
- 리스트명.pop(인덱스) : 인덱스 위치에 있는 원소를 제거한다. 매개변수가 없으면 마지막 요소를 제거한다. 매개변수가 없을때 default 값이 -1이다.

```python
lista = [1,2,3,4,5,6]
del lista[1]
print(lista) # [1,3,4,5,6]

lista.pop()
print(lista) # [1,3,4,5]

lista.pop(1)
print(lista) # [1,4,5]
```

- 리스트.remove(값) : 리스트 내부에 있는 **값**을 직접 제거한다. 여러개의 값을 제거하려면 아래와 같은 방법을 쓰거나 반복문을 쓰도록

**리스트에 여러개의 원소를 제거하는 방법**

- del 리스트명[인덱스 : 인덱스] : 이처럼 범위를 표시하여 여러개의 원소를 지울 수 있다. 원소를 선택하듯이 생각하면 된다.
- 리스트.clear() : 리스트의 요소를 모두 제거할때 사용한다.

**리스트 내부에 있는지 확인하는 연산자**

- 값 in 리스트	: 값이 있는지 확인한다.
- 값 not in 리스트 : 값이 없는지 확인한다. 없으면 true를 반혼하는 것이 특징이다.

위의 리스트에 관한 내용을 숙지해야 후에 딥러닝을 공부하는데 지장이 없을 것이다. 모르면 다시와서 보는 절차를 밟도록 하자

### for 반복문

컴퓨터에게 반복적인 작업을 시키기 위한 방법이며, 사용 방법은 아래와 같다.

```python
for i in range(100):
    print("하이")
```

- range(100) : 범위 자료형 

앞서 배운 여러 개의 값을 나타낼 수 있게 해주는 **리스트** 와 같은 자료형을 사용하여 반복문을 적용하는것이 반복문의 기본이다.

#### for 반복문을 리스트와 함께 사용하기

기본 형태는 다음과 같다.

```python
for iterator in iterable:
    코드
```

-  iterator : 반복자를 말하며 next() 메소드로 순차적으로 호출 가능한 객체를말한다.
- iterable : list, string, tuple과 같은 멤버를 하나씩 차례로 반환이 가능한 객체를 말한다.

### 딕셔너리와 반복문

- 리스트 : **인덱스를** 기반으로 자료를 저장하는 자료형, []기호로 선언
- 딕셔너리 : **키**를 기반으로 자료를 저장하는 자료형, {}기호로 선언

그렇다면 차이점은 무엇일까? 차이점은 인덱스는 정수만 사용이 가능하지만 키는 문자열, 숫자, 불 형식을 사용할 수 있다. 이제 딕셔너리를 선언하는 방법을 알아보자.

```python
변수 = {
  	키 : 값,
  	키 : 값,
  	키 : 값,
  	...
  	키 : 값
}
# 키 : 문자열, 숫자, 불 등의 자료형이 올 수 있다.
```

#### 딕셔너리의 요소에 접근하기

리스트와 같이 [중괄호]로 접근이 가능하며, 중괄호 안에 키 값을 입력하여 접근이 가능하다.

```python
dict_a = {
    "이름" : "개발"
  	"나이" : "군대 다녀온 20이면 좋겠다"
}

print(dict_a["이름"]) # '개발'
# 리스트처럼 중괄호 안에 키값을 입력하여 딕셔너리의 요소에 접근이 가능하다. 

dict_a = {
    "이름" : "개발",
  	"나이" : ["군대 다녀온 20이면 좋겠다", "미필 24는 좀"]
}

print(dict_a["나이"][0]) # 군대 다녀온 20이면 좋겠다
# 리스트처럼 요소안에 리스트를 넣을 수 있으며, 또한 추가적인 [중괄호]접근을 사용하여 리스트 안의 값에 접근할 수 있다.
```

#### 딕셔너리에 값 추가하기

- 딕셔너리[새로운 키] = 새로운 값

이와 같은 형태로 입력을 하면 딕셔너리에 추가되며, 키 값을 기존에 있던 키로 입력하면 새로운 값으로 대치된다.

#### 딕셔너리에 값 제거하기

- del 딕셔너리[제거하려는 키]

리스트의 요소를 제거하듯이 del 키워드로 제거하면 된다.

#### KeyError 예외

리스트에서  IndexError와 마찬가지로 잘못된 키값으로 접근할 시에 에러가 발생한다.

#### 딕셔너리 내부에 키가 잇는지 확인하기

- in 키워드 : 대부분 반복분에서 사용이 편리하여 자주 사용한다. 아래는 그 사용법이다.

```python
dictionary = {
  "이름" : "개발",
  "나이" : "두살",
  "지역" : "지구",
  "언어" : "파이썬"
}

for key in dictionary:
  print(dictionary[key])
```

- get() 함수 : 딕셔너리.get("키값")와 같이 사용이 가능하며, 만약 존재하지 않는 키값을 입력 받을 경우 **None을 출력**하는 것이 특징이다.	

```python
dictionary = {
  "이름" : "개발",
  "나이" : "두살",
  "지역" : "지구",
  "언어" : "파이썬"
}

value = dictionary.get("존재하지 않는 키")
print("값: ", value) # 값: None
```

#### for 반복문: 딕셔너리와 함께 사용하기

- 키가 있는지 확인하는 in키워드를 사용해 사용이 가능하다. 위에서 이미 사용하였으므로 알잘딱깔센 써라.

### 반복문과 while반복문

추가적으로 for 반복문에 많이 사용되는 자료형을 알아보

### 반복문과 while반복문

#### range 자료형

추가적으로 for 반복문에 많이 사용되는 자료형을 알아보겠다. 

- range : 범위 자료형이며, 특정한 횟수만큼 반복을 돌리고 싶으면 아래와 같이 세 가지 형태의 **range**를 만들 수 있다.

```
# <class 'range'>의 형태로 나오므로 range라는 자료형인거를 믿자.
print(type(range(6)))
# 0 부터 A-1까지의 정수로 range 생성
range(A)
# A 부터 B-1까지 정수로 range 생성
range(A, B)
# A 부터 B-1까지 범위의 정수를 만드는데, C만큼의 차이를 가짐
range(A, B, C)
```

#### range 자료형의 변환

range 자료형을 한 번 사용해보겠다. range를 출력하면 어떤 형식으로 출력이 되는지, list로 변환하면 어떻게 출력이 되는지 유심히 살펴보자.

```
a = range(5)
print(a)
# range(0,5) 를 출력한다.

print(list(range(5)))
# [0,1,2,3,4] 를 출력한다.
```

#### for 반복문: range와 같이 사용하기

위에서 배운 range의 자료형을 가지고 반복문을 작성한다면 아래와 같은 형태를 보인다.

```
for 숫자변수 in range:
    코드
# 기본형태는 위와 같다. 이제 직접 구현해서 사용해보자.

for i in range(5):
  print(i)
  # 0,1,2,3,4
for i in range(5,10):
  print(i)
  # 5,6,7,8,9
for i in range(0,10,3):
  print(i)
  # 0 3 6 9 가 출력되며, 이때 출발 지점은 0이고 끝은 9라는 것을 알아두자.
```

#### for 반복문: 리스트와 범위 조합하기

c언어에서 반복문을 사용하면 index값을 따로 정의하여 배열의 값에 접근하므로 몇 번째 값인지 접근이 나에겐 익숙했었다. 이제 python을 사용하여 한 번 구현해보자.

```
array = [4213,567,357,23423]

for element in array:
  print(element)
  # 4213 567 357 23423 이 나온다.
  
for i in range(len(array)):
  print("{}번째 수: {}".format(i, array[i]))
  # 이와 같이 range를 사용하여 array length만큼의 range 자료형을 선언해주어서 반복인자로 사용한다.
```

#### for 반복문: 반대로 반복하기

- range 범위를 매개변수 3개를 사용하여 반대로 사용하기.

```
# 역반복문
for i in range(5, 0-1,-1):
  print(i)
# 0은 포함하지 않으므로 0을 포함하려면 -1을 뻬야한다.
```

- reversed()  함수를 사용하기

```
for i in reversed(range(0,6)):
  print(i)
# 5 4 3 2 1 
```

하지만, reversed()함수의 결과가 **제네레이터**인것만 알고 주의하여 사용하지 않으면 원하는 결과가 나오지 않음을 알고 있자. 다음 주제에서 설명할 예정이다.

#### while 반복문 

리스트, 딕셔너리, 범위 자료형의 요소를 모두 순회하는 경우를 사용하려면 for문을 사용하면 된다. 

- 특정 횟수의 반복 : for 반복문
- 범용적인 반복 : while 반복문 

while 반복문의 기본 형태는 아래와 같다.

```
while boolean_expression:
  statement
```

- boolean_expression이 참인경우 계속 반복한다.

#### while 반복문: 상태를 기반으로 반복하기 

- 조건문 : 리스트 내부에 요소가 있는 동안

```
list_a = [1,2,1,2,1,2,]
value = 2

while value in list_a:
  list_a.remove(value)
  # list_a 내부에 value가 있다면 실행시키는 문장이다.
  
print(list_a)
```

#### while 반복문: 시간을 기반으로 반복하기

시간을 기반으로 반복하려면 **유닉스 타임**이라는 개념을 알아야 한다. -> 1970년 1월 1일 0시 0분 0초를 기준으로 몇 초가 지났는지를 float로 나타낸 것. 이를 잘 활용하면 시간을 기준으로 프로그램을 조정할 수 있다.

```
import time
# 시간 관련 모듈을 가져온

number = 0

target_tick = time.time() +5
while time.time() < target_tick:
  number +=1
# 5초동안 반복한 횟수를 의미한다. 그냥 5초동안 while문을 얼마나 돌리는지 성능을 나타내는 함수
print(number)

```

while 반복문: break 키워드 / continue 키워드

- break : **반복문**을 벗어날 때 사용하는 키워드
- continue : **현재 반복문을** 벗어날 때 사용하는 키워드

### 문자열, 리스트, 딕셔너리 관련 기본함수

다른 언어에서 보기 힘들 파이썬의 고유한 기능이라고 할 수 있을 정도의 함수들을 다뤄보겠다.

#### 리스트에 적용할 수 있는 함수

- min(리스트) : 리스트 내의 최소값을 구한다.
- max(리스트) : 리스트 내의 최댓값을 구한다.
- sum(리스트) : 리스트의 전체 합을 구한다.

#### reversed 함수로 리스트 뒤집기

- reversed(리스트) : 매개변수에 리스트를 넣어서 리스트르 뒤집을 수 있다. 하지만 주의할 점이 2가지나 있다.

```
list_man = [1,2,3,4,5]
list_reverse = reversed(list_man)

print(list_reverse)
# <list_reverseiterator object at 0x7fab600b1be0> : 이터레이터 (뒤에서 설명)
print(list(list_reverse))
# [5, 4, 3, 2, 1]
```

- list_reverse에 reversed(list_man)을 한 값이 저장되었을 터인데 어떻게 된일일까? 

**reversed 함수의 결과가 제네레이터이기 때문이다.**

제네레이터는 함수의 결과를 여러번 활용하지 않기때문에 곧바로 넣어서 사용해야 한다. 

#### enumerate() 함수와 반복문 조합하기

이전에 요소의 인덱스와 요소를 같이 출력하기 위해 range(len(array))와 같은 힘들짓을 했던것이 기억이 날것이다. 하지만, 이제 enumerate를 사용한다면 인덱스를 따로 구할 필요 없이 간단하게 뽑아낼 수 있다. 우선 사용법을 알아보자.

```
list_a = ["요소A","요소B","요소C"]

print(list_a) # 단순 출력

print(enumerate(list_a)) # enumerate 함수를 이용해 출력
<list_reverseiterator object at 0x7feaa8021be0>
print(type(enumerate(list_a))) # 타입을 알아보자
<class 'enumerate'>
print(list(enumerate(list_a))) # 리스트로 강제 변환해서 출력
[(0, '요소A'), (1, '요소B'), (2, '요소C')] # 튜플의 리스트 형태가 나왔다.

###### 여기가 가장 핵심인 부분이다 ######
for i, value in enumerate(list_a):
  print(i, value)
  
```

- **reversed(), enumerate()**-> 지금까지 이것들을 그대로 출력하면 이상하게 <list_reverseiterator object at 0x7feaa8021be0> 이런 형식의 출력이 나온것을 확인할 수 있다. 이는 **이터레이터에서 확인하자!! 매우 중요한 것이다. 내가 아직까지 모르니까 좀 더 자세히 보도록.** 
- 튜플의 형태에 대응하여 for 안의 조건문의 i, value값도 순서대로 적어서 사용하면 반복문 내에서 사용이 가능하다.

#### 딕셔너리의  items() 함수와 반복문 조합하기

- List <-> enumerate() : for i, value in enumerate(list) 형태로 반복문을 작성할 수 있었다.

그렇다면, 리스트의 친척급인 딕셔너리에서도 이와 같은 함수를 사용할 수 있지 않을까? -> **items()**가 그 해답이다. 리스트에서 enumerate를 사용했던 것처럼, 딕셔너리에서 items()를 사용해보는 절차를 밟아보도록하자

```
dict_a = {
  "a" : "value_a",
  "b" : "value_b",
  "c" : "value_c",
  "d" : "value_d",
}

print(dict_a.items())
# dict_items([('a', 'value_a'), ('b', 'value_b'), ('c', 'value_c'), ('d', 'value_d')])
# items()함수 역시 튜블의 리스트 형태로 키값과 요소를 반환한다.

###### 여기도 역시 핵심 부분 #####
for key, element in dict_a.items():
  print(key, element)
```

- items() : enumerate()와 달리 바로 출력해도 값이 나온다.
- 튜플의 형태에 대응하여 key, value 값을 순서대로 적으면 반복문 내에서 사용이 가능하다.

#### 리스트 내포(List comprehension)

리스트의 원소를 집어넣을 때, C언어에서는 직접 집어넣거나 반복문을 사용하여 넣었었다. 하지만 파이썬은 리스트를 **선언하는 단계에서 for문을 사용하여 한 줄로 선언이 가능하다.**

```
# 기존 방식
array1 = []
for i in range(5):
  array.append(i)
print(array1)
# List comprehensio 사용
array2 = [ i for i in range(5)]
print(array2)
```

- 리스트이름 = [표현식 for 반복자 in 반복할 수 있는 것]

리스트 내포는 위와 같은 문법으로 쓸 수 있다. 추가적으로 if를 포함한 리스트 내포는 아래와 같다.

- 리스트 이름 = [표현식 for 반복자 in 반복할 수 있는 것 if 조건문]

```
array[1,2,3,4,5,6,7,8]
output = [i for i in array if i%2 !=0]  # 홀수만 저장
print(output)
# 1 3 5 7
```

#### 문자열의 join()함수

문자열.join(문자열로 구성된 리스트) 와 같은 형태로 사용된다. 사용법은 아래와 같다.

```
>>> print("::".join(["1","2","3","4","5"]))
1::2::3::4::5
```

- 리스트의 요소를 해당 문자열로 연결한다.

#### 이터레이터

반복분의 구성 -> for **반복자** in **반복할 수 있는 것**

- Iterable : 위의 반복문에서 반복할 수 있는 것을 의미한다. 즉, 내부에 있는 요소들을 차례차례로 꺼낼 수 있는 객체를 의미한다. **리스트, 딕셔너리, 문자열 튜플**이 이터러블이다. 
- Iterator : Iterable 중에서 **next()**함수를 적용해 하나하나 꺼낼 수 있는 요소를 Iterator라고 한다.

아까 reversed(), enumerate() 함수를 리턴하였을 때 **이터레이터를 반환한다.**의 의미를 알아볼 것인데, 일단 코드부터 살펴보자.

```
numbers = [1,2,3,4,5,6]
r_num = reversed(numbers)

print("reversed_numbers:", r_num)
print(next(r_num))
print(next(r_num))
print(next(r_num))
print(next(r_num))
print(next(r_num))
print(next(r_num))

# reversed_numbers: <list_reverseiterator object at 0x7fe090081be0>
# 6
# 5
# 4
# 3
# 2
# 1
```

- r_num의 키의 반환형은 이터레이터임을 알 수 있다. 여기서 next() 함수를 이용해 내부의 요소를 하나하나 꺼낼 수 있다. 
- 메모리의 효율성을 위하여 큰 크기의 리스트를 복제한 뒤 뒤집어서 리턴하는 것 보다는 기존에 있던 리스트를 활용하여 다음에 올 수의 주소만 뒤집어 주면 해결되는 문제이기 때문이다. 