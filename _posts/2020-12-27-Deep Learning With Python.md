---
title: 케라스 창시자에게 배우는 딥러닝(Deep Learning with Python)
toc: true
categories: 
    -   Deep Learning
---
## AI, Machine Learning 그리고 Deep Learning
우리가 말하는 AI(인공 지능)연구는 보통의 사람이 수행하는 지능적인 작업을 자동화하기 위한 연구 활동이다. 여기서는 AI, Machine Learning 그리고 Deep LearningS이 무엇이며 어떤 범주안에 속하는지 알아 볼 것이다.

### Symbolic AI
Symbolic AI는 **명시적인 규칙**을 충분하게 많이 만들어 지식을 다루면 인간 수준의 AI를 만들 수 있다는 접근방식이다. => 전문가 시스템(Expert System)으로 인기가 절정에 달함
-   하지만, 복잡하고 불분명한 문제를 해결하기 위해 **명시적인 규칙**을 찾는것이 어려워 Symbolic AI를 대체하기 위한 새로운 방안이 등장함. => Machine Learning

### Machine Learning
프로그래머가 직접 만든 데이터 처리 규칙 대신에 컴퓨터가 데이터를 보고 자동으로 이런 규칙을 학습할 수 있을까? -> 이와 같은 질문이 아래의 표에서 볼 수 있듯이 Symbolic AI에서 Machine Learning으로 나아간 패러다임으로 진화가 되었다.  

|Input|Program|Output|
|:-----|:-------:|------:|
|규칙, 데이터|Symbolic AI|해답|
|해답, 데이터|Machine Learning|규칙|  

따라서 머신러닝은 **명시적으로 프로그램(규칙)**이 되는 것이 아니라 해답과 데이터에서 **통계적 구조(규칙)를 찾아** 작업을 자동화 하기위한 규칙을 만들어 낸다. 이러한 과정을 **훈련**이라 하며 이를 위해서는 아래 세 가지가 필요하다. 추가로 위의 표를 참고하면 이해하기 편할 것이다.
-   입력 데이터 포인트(데이터)
-   기대 출력(해답)
-   알고리즘의 성능을 측정하는 방법  (Machine Learning Algorithm)

머신 러닝 모델은 입력 데이터를 의미있는 출력으로 변환하는 알고리즘이다. 즉, 입력 데이터를 기반으로 **기대 출력**에 가깝게 만드는 유용한 표현을 학습하는 것이다. 

### Deep Learning
딥러닝은 머신 러닝의 특정한 한 분야이며 연속된 **층**에서 점진적으로 의미있는 표현을 배우는 학습 방식이다. 각 층에는 가중치가 저장되어 있으며, 입력 데이터를 해답에 최대한 가깝게 학습시키는 **가중치 매개변수**를 찾는 것이 딥러닝에서 층의 역할이다.

## 신경망
### 텐서
텐서는 데이터(수치형 데이터를 다루므로 숫자)를 위한 컨테이너이며 임의의 차원 개수를 가지는 행렬의 일반화된 모습이다. 아래에서 차원(dimension, 혹은 axis, rank라고 부르기도 함)에 따른 텐서를 제시하여 기본적인 성질을 알아보겠다.
-   Scalar(0D Tensor) : **하나의 숫자**만 담고있는 텐서를 **스칼라**라고 한다. 넘파이에서는 float32, float64 타입의 숫자가 스칼라텐서이다. 숫자가 하나이기 때문에 dimension이 0 임을 알 수 있다.
-   Vector(1D Tensor) : 숫자의 배열을 **벡터**라고 하며 **하나의 축**을 가지고 있다. 
-   Matrix(2D Tensor) : 벡터의 배열을 **행렬**이라고 하며 2개의 축을 가지고 있다.
-   3D Tensor : 행렬들을 하나의 새로운 배열로 합친것을 **3D텐서**라고한다. 형상은 직육면체 형태로 앞에서 부터 합쳐온 방식과 같이 앞의 것들을 하나의 배열로 합치면 더 높은 **고차원 텐서**를 구현할 수 있다.  

위와 같이 텐서가 정의되며, 좀 더 세부적인 속성은 다음과 같다.
-   Rank : numpy의 ndim속성을 통해 나온 값이며 축의 개수를 의미한다.
-   shape : 텐서의 각 축을 따라 얼마나 많은 차원(여기서 말하는 차원은 tensor의 차원이 아닌 축을 따라서 얼마나 많은 원소가 있는지 나타내는 것이다.)이 있는지 나타내는 파이썬의 tuple이다. 
-   Data Type : float32, float64, uint8와 같이 텐서에 포함된 데이터타입이다.  

## 배치 데이터
딥러닝 모델은 한번에 전체 데이터셋을 처리하지 않는다.(<a href="https://jamangstangs.github.io/deeplearning/Deep-Learning-from-Scratch#미니배치-학습">미니배치 학습을 하는 이유</a>) 그 대신에 데이터를 나누는데, 슬라이싱을 사용하여 미니배치를 구현하면 다음과 같다.  

```python
batch = train_images[128*n:128*(n+1)]
```   

위와 같은 방식으로 배치 데이터를 다룰 때, 첫 번째 축을 **배치축** 혹은 **배치 차원** 이라고 한다. 보통 첫 번째 축에서 데이터의 개수(samples)가 저장되어 있기 때문이다.

### 텐서의 실제 사례
-   벡터 데이터 : 데이터 자체는 1D 텐서이며, 이를 모아둔 배열이므로 데이터의 형상은 **2D 텐서**를 이루게 된다. 배열을 이룬다는 의미는 샘플의 개수를 모아서 배열에 정리함을 의미하므로 주요 정보들을 벡터에 저장할 수 있다. 
    -   **(samples, features)**
-   시계열 데이터 or 시퀀스 데이터 : 데이터 자체가 2D 텐서이며(1D 텐서 각각에서 시간 데이터를 넣어야 한다고 생각하면 데이터 자체가 2D임을 알 수 있다.),데이터에서 시간을 꼭 포함하여야 할 때 시간 축을 포함하여 3D 텐서의 형태로 저장하게 된다. **관례적으로 시간 축은 두 번째 축**이다. 
    -   **(samples, timesteps, features)**
-   이미지 : 데이터 자체가 3D 텐서(높이, 가로, 색상)이며, 데이터를 모아서 하나의 이미지 데이터로 구축하면 4D 텐서가 됨을 알 수 있다.
    -   Channel-last : **(samples, height, width, channels)** -> 텐서플로 머신 러닝 프레임 워크가 지원하는 데이터 형식
    -   Channel-first : **(samples, channels, height, width)** -> 씨아노에서 사용하는 방식 
    -   **케라스에서는 둘 다 지원한다.**
-   동영상 :  이미지 데이터를 **하나의 프레임**으로 생각한다면 비디오 데이터 하나는 **여러 개의 프레임**을 가지므로 5D 텐서를 가짐을 알 수 있다.
    -   **(samples, frames, height, width, channels)**

## 신경망의 구조
### 층(Layers)
하나 이상의 텐서를 입력받아 하나 이상의 텐서를 출력하는 데이터 처리 모듈이다. 대부분의 Layer는 **가중치**라는 층의 **상태**를 가진다. 가중치에는 SGD(확률적 경사 하강법)을 통해 학습되는 텐서이며 여기에 **네트워크가 학습한 지식**이 담겨있다. 층에 따라서 데이터 처리방식은 아래와 같다.
-   Dense Layer(Fully Connected Layer) : 2D Tensor로 저장된 벡터 데이터
-   Recurrent Layer : 3D Tensor로 저장된 시퀀스 데이터
-   Convolution Layer : 4D Tensor로 저장된 이미지 데이터  
 
### 층의 네트워크(Networks of Layers)
-   가지(Branch)가 2개인 네트워크
-   출력이 여러개인 네트워크
-   인셉션(Inception) 블록

### 손실함수와 옵티마이저
-   손실함수(Loss Function) : 훈련을 하는동안 최소화 해야한다.
-   옵티마이저(Optimizer) : 손실함수를 기반으로 네트워크가 어떻게 업데이트 될지 결정한다. SGD와 같은 방법을 구현한다. 

## 케라스
간편하게 거의 모든 종류의 딥러닝 모델을 구현할 수 있는 파이썬을 위한 딥러닝 **프레임워크**이다. 케라스는 아래와 같은 특징을 가지고 있다.
-   같은 코드로 CPU, GPU에서 원활하게 실행이 가능하다.
-   Convolutional Networks, Rerurrent Networks를 사용이 가능하며 자유롭게 조합하여 사용이 가능하다.
-   텐서플로, 씨아노, CNTK(마이크로소프트)와 같은 백엔드 엔진을 사용할 수 있다.

##

리눅스 GUI 서맃 startx 명령어 실행



